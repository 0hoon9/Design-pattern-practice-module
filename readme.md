# 디자인패턴

디자인 패턴이란 반복적으로 일어나는 문제들을 어떻게 풀어나갈 것인가에 대한 해결책이다.
---

- ## 디자인 패턴의 분류
디자인 패턴은 생성패턴, 구조패턴, 행위패턴 3개의 범주로 분류된다.

1. ### 생성패턴
객체 생성에 관련된 패턴이다.  
객체 생성과 조합을 캡슐화.   
객체가 생성 및 변경되어도 구조에 영향을 주지않는 유연성 제공.  

2. ### 구조패턴
클래스와 객체를 조합해 더 큰 구조를 만드는 패턴.  
예를 들어 서로다른 인터페이스를 지닌 2개의 객체를 묶어, 단일 인터페이스로 제공하거나 객체들을 서로 묶어 새로운 기능을 제공하는 패턴이다.  

3. ### 행위패턴
객체나 클래스 사이의 알고리즘이나 책임 분배에 관련된 패턴.  
한 객체가 혼자 수행하지 못하는 작업을 여러개의 객체로 어떻게 분해하는지 등 객체사이의 결합도를 최소화하는 것에 중점을 둔다.
---

- ## JS에서 자주 사용하는 디자인 패턴의 종류.
1. ### 모듈 패턴 - 전체 어플리케이션의 일부를 독립된 코드로 분리시키는 것 (유지보수에 용이)
필요한 로직만 로드하여 메모리 낭비를 줄인다.  
코드 개선시 모듈을 사용하는 모든 어플리케이션 동작이 개선된다.  
재사용하기 용이하다.

2. ### 생성자 패턴 - new 키워드를 사용하여 동적으로 객체를 생성하는 패턴이다.
생성자 패턴은 인스턴스마다 메서드가 생성돼 메모리가 낭비된다.  
위 문제는 prototype패턴과의 조합으로 해결할 수 있다.  
생성자 함수 안에서의 this는 생성된 객체를 가르킨다.  

3. ### 싱글톤 패턴 - 여러개의 인스턴스 생성을 피하는 패턴
특정 클래스의 인스턴스를 오직 하나만 유지하고, 동일한 클래스로 새로운 객체를 생성해도 처음 만들어진 객체를 얻게 된다.  
객체 리터럴만으로 비공개 멤버를 정의할수 없기에 클로저를 활용한다.  
대표적인 싱클톤 패턴의 예는 객체 리터럴이다.  

4. ### 추상 팩토리 패턴 - 공통 클래스를 정의하여 인스턴스 생성을 추상화 해놓고 실제 인스턴스 생성을 서브클래스에 위임한다.
분기문을 통한 객체생성 로직이 사라진다. (유연해진다)  
함수간 의존성을 낮춰 코드 관리가 용이하다.

5. ### 빌더 패턴 - setter메서드와 체이닝을 통해서 특정 객체를 조합해가는 패턴이다.
생성자를 이용해 멤버를 초기화하는 것과 달리 인수(인수위치, 개수)에 의존할 필요가 없다.

6. ### Iterator 패턴 - iterator와 iterable 프로토콜을 지키면서 연속된 데이터를 순회하는 패턴
타입에 상관없이 모든 내용을 출력하는 작업에 용이하다.  
Generator : Iterator이면서 Iterable한 값을 반환하는 함수

7. ### Decoration 패턴 - 하나의 객체에 여러가지 기능을 동적으로 추가하는 패턴
상속보다 유연성이 뛰어나며, 동적으로 특정객체에 기능을 추가하려는 경우에 용이하다.

8. ### Observer 패턴 - 각 모듈의 중간에서 서로의 상태변화를 관찰하는 관찰자 객체를 만드는 패턴
모듈간의 의존성을 최소화하여 코드의 품질을 향상시킬수 있다.